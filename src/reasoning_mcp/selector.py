"""Method selection for reasoning-mcp.

This module provides dataclasses and the MethodSelector for intelligent
selection of reasoning methods based on problem characteristics.
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from reasoning_mcp.models.core import MethodCategory, MethodIdentifier

from reasoning_mcp.registry import MethodRegistry


__all__ = [
    "SelectionHint",
    "SelectionConstraint",
    "MethodRecommendation",
    "SelectionRule",
    "MethodSelector",
    "detect_problem_patterns",
    "estimate_complexity",
    "SELECTION_RULES",
]


@dataclass(frozen=True)
class SelectionConstraint:
    """User-specified constraints for method selection.

    These constraints allow users to influence or restrict the method
    selection process based on their requirements.

    Attributes:
        allowed_methods: If set, only these methods can be selected
        excluded_methods: Methods that should not be selected
        allowed_categories: If set, only methods from these categories
        excluded_categories: Categories to exclude from selection
        max_complexity: Maximum allowed complexity (1-10)
        require_branching: Must support branching if True
        require_revision: Must support revision if True
        max_tokens_budget: Maximum token budget for the reasoning session
        preferred_methods: Methods to prefer (will be scored higher)
    """
    allowed_methods: frozenset[str] | None = None
    excluded_methods: frozenset[str] = field(default_factory=frozenset)
    allowed_categories: frozenset[str] | None = None
    excluded_categories: frozenset[str] = field(default_factory=frozenset)
    max_complexity: int | None = None
    require_branching: bool = False
    require_revision: bool = False
    max_tokens_budget: int | None = None
    preferred_methods: frozenset[str] = field(default_factory=frozenset)

    def __post_init__(self) -> None:
        """Validate constraint values."""
        if self.max_complexity is not None and not 1 <= self.max_complexity <= 10:
            raise ValueError(f"max_complexity must be 1-10, got {self.max_complexity}")
        if self.max_tokens_budget is not None and self.max_tokens_budget < 100:
            raise ValueError(f"max_tokens_budget must be >= 100, got {self.max_tokens_budget}")

    def is_method_allowed(self, identifier: str) -> bool:
        """Check if a method is allowed by these constraints.

        Args:
            identifier: Method identifier to check

        Returns:
            True if allowed, False if excluded
        """
        # Check explicit exclusions
        if identifier in self.excluded_methods:
            return False
        # Check allowed list (if specified)
        if self.allowed_methods is not None:
            return identifier in self.allowed_methods
        return True

    def is_category_allowed(self, category: str) -> bool:
        """Check if a category is allowed by these constraints.

        Args:
            category: Category to check

        Returns:
            True if allowed, False if excluded
        """
        if category in self.excluded_categories:
            return False
        if self.allowed_categories is not None:
            return category in self.allowed_categories
        return True


@dataclass(frozen=True)
class SelectionHint:
    """Hints for method selection based on problem analysis.

    SelectionHints are generated by analyzing the input problem and provide
    guidance to the MethodSelector about what characteristics to look for
    in a suitable reasoning method.

    Attributes:
        problem_type: Detected type of problem (e.g., "mathematical", "ethical", "debugging")
        complexity_estimate: Estimated complexity (1-10)
        requires_branching: Whether the problem likely needs branching exploration
        requires_iteration: Whether the problem needs iterative refinement
        requires_external_tools: Whether external tools/actions may be needed
        domain_tags: Tags identifying the problem domain
        keywords: Important keywords extracted from the problem
        suggested_min_depth: Suggested minimum reasoning depth
        confidence: Confidence in these hints (0.0-1.0)
    """
    problem_type: str
    complexity_estimate: int = 5
    requires_branching: bool = False
    requires_iteration: bool = False
    requires_external_tools: bool = False
    domain_tags: frozenset[str] = field(default_factory=frozenset)
    keywords: frozenset[str] = field(default_factory=frozenset)
    suggested_min_depth: int = 1
    confidence: float = 0.5

    def __post_init__(self) -> None:
        """Validate hint values."""
        if not 1 <= self.complexity_estimate <= 10:
            raise ValueError(f"complexity_estimate must be 1-10, got {self.complexity_estimate}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"confidence must be 0.0-1.0, got {self.confidence}")
        if self.suggested_min_depth < 1:
            raise ValueError(f"suggested_min_depth must be >= 1, got {self.suggested_min_depth}")


@dataclass(frozen=True)
class MethodRecommendation:
    """A recommendation for a reasoning method.

    Represents a scored recommendation from the MethodSelector, including
    the method identifier, score, and explanation for why it was recommended.

    Attributes:
        identifier: The recommended method identifier
        score: Recommendation score (0.0-1.0, higher is better)
        confidence: Confidence in this recommendation (0.0-1.0)
        reasoning: Explanation for why this method was recommended
        matched_tags: Tags that matched between problem and method
        strengths: Why this method is good for this problem
        weaknesses: Potential drawbacks for this problem
        alternative_to: If this is an alternative, what method it replaces
    """
    identifier: str
    score: float
    confidence: float
    reasoning: str
    matched_tags: frozenset[str] = field(default_factory=frozenset)
    strengths: tuple[str, ...] = field(default_factory=tuple)
    weaknesses: tuple[str, ...] = field(default_factory=tuple)
    alternative_to: str | None = None

    def __post_init__(self) -> None:
        """Validate recommendation values."""
        if not 0.0 <= self.score <= 1.0:
            raise ValueError(f"score must be 0.0-1.0, got {self.score}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"confidence must be 0.0-1.0, got {self.confidence}")
        if not self.reasoning:
            raise ValueError("reasoning cannot be empty")

    def __lt__(self, other: MethodRecommendation) -> bool:
        """Compare recommendations by score for sorting."""
        return self.score < other.score

    def __eq__(self, other: object) -> bool:
        """Check equality based on identifier."""
        if not isinstance(other, MethodRecommendation):
            return NotImplemented
        return self.identifier == other.identifier

    def __hash__(self) -> int:
        """Hash based on identifier."""
        return hash(self.identifier)


# Pattern detection functions

def detect_problem_patterns(text: str) -> dict[str, bool]:
    """Detect common problem patterns in text.

    Returns dict mapping pattern names to whether they were detected.
    """
    text_lower = text.lower()
    return {
        "mathematical": bool(re.search(r'\b(calculate|compute|solve|equation|formula|prove)\b', text_lower)),
        "code": bool(re.search(r'\b(code|function|class|bug|error|debug|implement)\b', text_lower)),
        "ethical": bool(re.search(r'\b(ethical|moral|right|wrong|should|ought)\b', text_lower)),
        "creative": bool(re.search(r'\b(create|design|invent|imagine|novel|innovative)\b', text_lower)),
        "analytical": bool(re.search(r'\b(analyze|compare|evaluate|assess|examine)\b', text_lower)),
        "causal": bool(re.search(r'\b(cause|effect|why|because|reason|result)\b', text_lower)),
        "decision": bool(re.search(r'\b(decide|choice|option|alternative|tradeoff)\b', text_lower)),
        "multi_step": bool(re.search(r'\b(step|first|then|next|finally|process)\b', text_lower)),
    }


def estimate_complexity(text: str, patterns: dict[str, bool]) -> int:
    """Estimate problem complexity (1-10)."""
    complexity = 3  # base complexity

    # Increase for detected patterns
    pattern_count = sum(patterns.values())
    complexity += min(pattern_count, 4)

    # Increase for length
    word_count = len(text.split())
    if word_count > 100:
        complexity += 1
    if word_count > 300:
        complexity += 1

    return min(10, max(1, complexity))


@dataclass(frozen=True)
class SelectionRule:
    """A rule for method selection scoring.

    Attributes:
        pattern: Pattern name to match
        method: Method identifier to recommend
        score_boost: Score boost when pattern matches (0.0-1.0)
        reason: Explanation for this rule
    """
    pattern: str
    method: str
    score_boost: float
    reason: str

    def __post_init__(self) -> None:
        if not 0.0 <= self.score_boost <= 1.0:
            raise ValueError(f"score_boost must be 0.0-1.0, got {self.score_boost}")


SELECTION_RULES: list[SelectionRule] = [
    SelectionRule("mathematical", "mathematical_reasoning", 0.3, "Math problems benefit from formal reasoning"),
    SelectionRule("mathematical", "chain_of_thought", 0.2, "Step-by-step helps with calculations"),
    SelectionRule("code", "code_reasoning", 0.4, "Code-specific reasoning for programming tasks"),
    SelectionRule("code", "react", 0.2, "ReAct can execute and verify code"),
    SelectionRule("ethical", "ethical_reasoning", 0.4, "Multi-framework ethical analysis"),
    SelectionRule("ethical", "dialectic", 0.2, "Consider multiple perspectives"),
    SelectionRule("creative", "lateral_thinking", 0.3, "Non-linear creative reasoning"),
    SelectionRule("creative", "tree_of_thoughts", 0.2, "Explore multiple creative paths"),
    SelectionRule("analytical", "chain_of_thought", 0.2, "Systematic analysis benefits from step-by-step"),
    SelectionRule("analytical", "self_consistency", 0.2, "Multiple perspectives increase reliability"),
    SelectionRule("causal", "causal_reasoning", 0.4, "Direct causal analysis capability"),
    SelectionRule("decision", "tree_of_thoughts", 0.3, "Explore decision branches"),
    SelectionRule("decision", "mcts", 0.2, "Monte Carlo search for decision optimization"),
    SelectionRule("multi_step", "sequential_thinking", 0.3, "Linear step-by-step for processes"),
    SelectionRule("multi_step", "least_to_most", 0.2, "Progressive problem decomposition"),
]


class MethodSelector:
    """Intelligent selection of reasoning methods.

    The MethodSelector analyzes problems and recommends appropriate
    reasoning methods based on detected patterns and constraints.
    """

    def __init__(self, registry: MethodRegistry) -> None:
        """Initialize with a method registry.

        Args:
            registry: Registry containing available methods
        """
        self._registry = registry

    def analyze(self, problem: str) -> SelectionHint:
        """Analyze a problem and generate selection hints.

        Args:
            problem: The problem text to analyze

        Returns:
            SelectionHint with detected patterns and recommendations
        """
        patterns = detect_problem_patterns(problem)
        complexity = estimate_complexity(problem, patterns)

        # Determine primary problem type
        problem_type = "general"
        for ptype, detected in patterns.items():
            if detected:
                problem_type = ptype
                break

        # Collect domain tags
        domain_tags = frozenset(p for p, detected in patterns.items() if detected)

        return SelectionHint(
            problem_type=problem_type,
            complexity_estimate=complexity,
            requires_branching=patterns.get("decision", False) or patterns.get("creative", False),
            requires_iteration=patterns.get("multi_step", False),
            requires_external_tools=patterns.get("code", False),
            domain_tags=domain_tags,
            confidence=0.7 if domain_tags else 0.4,
        )

    def recommend(
        self,
        problem: str,
        *,
        constraints: SelectionConstraint | None = None,
        max_recommendations: int = 3,
    ) -> list[MethodRecommendation]:
        """Recommend methods for a problem.

        Args:
            problem: The problem text
            constraints: Optional constraints on selection
            max_recommendations: Maximum recommendations to return

        Returns:
            List of method recommendations sorted by score
        """
        hints = self.analyze(problem)
        patterns = detect_problem_patterns(problem)
        constraints = constraints or SelectionConstraint()

        # Score all available methods
        scores: dict[str, float] = {}
        reasons: dict[str, list[str]] = {}

        for metadata in self._registry.list_methods():
            method_id = str(metadata.identifier)

            # Check constraints
            if not constraints.is_method_allowed(method_id):
                continue
            if not constraints.is_category_allowed(str(metadata.category)):
                continue
            if constraints.max_complexity and metadata.complexity > constraints.max_complexity:
                continue
            if constraints.require_branching and not metadata.supports_branching:
                continue
            if constraints.require_revision and not metadata.supports_revision:
                continue

            # Base score
            scores[method_id] = 0.1
            reasons[method_id] = []

            # Apply selection rules
            for rule in SELECTION_RULES:
                if patterns.get(rule.pattern) and rule.method == method_id:
                    scores[method_id] += rule.score_boost
                    reasons[method_id].append(rule.reason)

            # Boost preferred methods
            if method_id in constraints.preferred_methods:
                scores[method_id] += 0.2
                reasons[method_id].append("User preferred method")

            # Tag matching boost
            matched_tags = hints.domain_tags & metadata.tags
            if matched_tags:
                scores[method_id] += 0.1 * len(matched_tags)
                reasons[method_id].append(f"Matched tags: {', '.join(matched_tags)}")

        # Build recommendations
        recommendations = []
        for method_id, score in sorted(scores.items(), key=lambda x: -x[1]):
            if score < 0.15:  # Filter low scores
                continue

            metadata = self._registry.get_metadata(method_id)
            if not metadata:
                continue

            recommendations.append(MethodRecommendation(
                identifier=method_id,
                score=min(1.0, score),
                confidence=hints.confidence,
                reasoning="; ".join(reasons[method_id]) or "General-purpose method",
                matched_tags=hints.domain_tags & metadata.tags,
                strengths=tuple(metadata.best_for[:3]),
                weaknesses=tuple(metadata.not_recommended_for[:2]),
            ))

            if len(recommendations) >= max_recommendations:
                break

        return recommendations

    def select_best(
        self,
        problem: str,
        *,
        constraints: SelectionConstraint | None = None,
    ) -> str | None:
        """Select the single best method for a problem.

        Args:
            problem: The problem text
            constraints: Optional constraints on selection

        Returns:
            The best method identifier, or None if no suitable method
        """
        recommendations = self.recommend(problem, constraints=constraints, max_recommendations=1)
        return recommendations[0].identifier if recommendations else None
